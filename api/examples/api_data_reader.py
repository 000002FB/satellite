#!/usr/bin/env python3
"""
Read/decrypt Satellite API data received via Blockstream Satellite
"""

import os, sys, argparse, textwrap, struct, zlib, time, logging, socket, errno
import fcntl
from datetime import datetime
from textwrap import fill
import gnupg, getpass


# Constants/definitions
BLOCKSAT_PKT_HEADER_FORMAT = '!c3xI'
BLOCKSAT_PKT_HEADER_LEN    = 8
TYPE_API_DATA              = b'\x01'
USER_HEADER_FORMAT         = '255sxi' # Message header from `api_data_sender.py`
USER_HEADER_LEN            = 255 + 1 + 4
MAX_READ                   = 2**16
DOWNLOAD_DIR               = "downloads"
SIOCGIFINDEX               = 0x8933 # Ioctl request for interface index
IP_MULTICAST_ALL           = 49


def save_file(data, filename=None):
    """Save data into a file

    Save given sequence of octets into a file with given name. If the name is
    not specified, use a timestamp as the file name.

    Args:
        data     : Data to save
        filename : Name of the file to save (optional)

    """
    # Save file into a specific directory
    if not os.path.exists(DOWNLOAD_DIR):
        os.makedirs(DOWNLOAD_DIR)

    if (filename is None):
        filename = time.strftime("%Y%m%d%H%M%S")

    # Write file with user data
    f = open(os.path.join(DOWNLOAD_DIR, filename), 'wb')
    f.write(data)
    f.close()

    logging.info("Saved in %s." %(os.path.join(DOWNLOAD_DIR, filename)))


def parse_user_data(data):
    """Parses the user-specific protocol data structure

    Parses the user-specific data structure generated by the
    "api_data_sender.py" example application. Unpacks the CRC32 checksum and the
    file name of the user-specific header. Then, validates the data integrity
    using the checksum and saves the file with the given file name.

    Args:
        data : Sequence of bytes with the raw received data buffer

    Returns:
        Boolean indicating whether the parsing was successful

    """

    if (len(data) < USER_HEADER_LEN):
        logging.warning("Message length is less than 260 bytes")

        info_str = ("Have you used the api_data_sender app with --send-raw "
                    "option or another transmission app? In this case, "
                    "consider running the api_data_reader app with "
                    "--save-raw option.")
        logging.info(fill(info_str, width=80))
        logging.info("We will fall back and save the raw data...")
        return False

    # Parse the user-specific header
    user_header = struct.unpack(USER_HEADER_FORMAT, data[:USER_HEADER_LEN])
    filename    = user_header[0].rstrip('\0')
    checksum    = user_header[1]

    # Validate data integrity
    user_data  = data[USER_HEADER_LEN:]
    data_crc32 = zlib.crc32(user_data)

    if (data_crc32 != checksum):
        logging.error("Checksum (%d) does not match the header value (%d)" %(
            data_crc32, checksum
        ))

        info_str = ("This could be because some data was lost over the "
                    "satellite link or because the message was sent without a "
                    "user-specific header containing a checksum. The latter "
                    "would be the case if using the api_data_sender app with "
                    "--send-raw option or if using another Blocksat message "
                    "transmission app. In this case, consider running the "
                    "api_data_reader app with --save-raw command-line option. "
                    "We will fall back and save the raw data...")
        logging.info(fill(info_str, width=80))

        return False
    else:
        logging.info("File: %s\tChecksum: %d\tSize: %d bytes" %(
            filename, checksum, len(user_data)))

    save_file(user_data, filename)

    return True


def unpack(udp_payload):
    """Unpack Blocksat Packet from UDP payload

    Args:
        udp_payload : UDP payload received via socket

    Returns:
        Tuple with the Blocksat Packet's payload and sequence number

    """

    header         = struct.unpack(BLOCKSAT_PKT_HEADER_FORMAT,
                                   udp_payload[:BLOCKSAT_PKT_HEADER_LEN])
    pkt_type       = chr(ord(header[0]) & ord(b'\x01'))
    more_fragments = (ord(header[0]) & ord(b'\x80')) != 0
    seq_num        = header[1]
    payload        = udp_payload[BLOCKSAT_PKT_HEADER_LEN:]

    assert(pkt_type == TYPE_API_DATA)
    assert(more_fragments == False),\
        "Blocksat Packet fragmentation over UDP is not supported"

    return (payload, seq_num)


def open_udp_sock(sock_addr, ifname):
    """Instantiate UDP socket

    Args:
        sock_addr : Socket address string
        ifname    : Network interface name

    Returns:
        Socket object

    """
    udp_sock_ip, udp_sock_port_str = sock_addr.split(":")
    udp_sock_port                  = int(udp_sock_port_str)
    assert(udp_sock_ip is not None), "UDP source IP is not defined"
    assert(udp_sock_port is not None), "UDP port is not defined"

    logging.debug("Connect with UDP socket %s:%s" %(udp_sock_ip,
                                                    udp_sock_port))
    try:
        # Open and bind socket to Blocksat API port
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

        # Allow reuse and bind
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        sock.bind(('', udp_sock_port))

        # Get the network interface index
        if (ifname is not None):
            ifreq   = struct.pack('16si', ifname, 0)
            res     = fcntl.ioctl(sock.fileno(), SIOCGIFINDEX, ifreq)
            ifindex = int(struct.unpack('16si', res)[1])
            logging.debug("Join multicast group %s on network interface %d" %(
                udp_sock_ip, ifindex
            ))
        else:
            logging.debug("Join group %s with the default network interface" %(
                udp_sock_ip
            ))
            ifindex = 0

        # Join multicast group on the chosen interface
        ip_mreqn = struct.pack('4s4si',
                               socket.inet_aton(udp_sock_ip),
                               socket.inet_aton('0.0.0.0'),
                               ifindex)
        sock.setsockopt(socket.IPPROTO_IP,
                        socket.IP_ADD_MEMBERSHIP,
                        ip_mreqn)

        # Make sure that this socket receives messages solely from the above
        # group that was explicitly joined above
        sock.setsockopt(socket.IPPROTO_IP, IP_MULTICAST_ALL, 0)
    except socket.error as e:
        if (e.errno == errno.EADDRNOTAVAIL):
            logging.error("Error on connection with UDP socket %s:%s" %(
                udp_sock_ip, udp_sock_port))
            logging.info("Use argument `--sock-addr` to define the socket address.")
        raise

    return sock


def main():
    parser = argparse.ArgumentParser(
        description=textwrap.dedent('''\
        Example Blockstream Satellite API data reader application

        Receives Blocksat API data via a UDP socket that listens to the API
        multicast address. By default, assumes that incoming messages are
        generated by the example "API data sender" application, which frames and
        encrypts the message prior to transmission. Thus, this application first
        attempts to decrypt the data using a local GnuPG key and, on successful
        decryption, validates the integrity of the data. In the end, saves the
        file in the "downloads/" directory.

        '''),
        formatter_class=argparse.RawDescriptionHelpFormatter
    )

    parser.add_argument('--sock-addr',
                        default="239.0.0.2:4433",
                        help='Multicast UDP address (ip:port) used to ' +
                        'listen for API data (default: 239.0.0.2:4433)')

    intf_arg = parser.add_mutually_exclusive_group(required=True)

    intf_arg.add_argument('-i', '--interface',
                          help="Network interface that receives API data. ")

    intf_arg.add_argument('--demo',
                          action="store_true",
                          help="Use the same interface as demo-rx, i.e. an " +
                          "automatically defined interface. (default: False)")

    parser.add_argument('-g', '--gnupghome', default=".gnupg",
                        help='GnuPG home directory (default: .gnupg)')

    encr_arg = parser.add_mutually_exclusive_group()

    encr_arg.add_argument('--save-raw', default=False,
                          action="store_true",
                          help='Save the raw decrypted data in the ' +
                          '\"downloads/\" folder while ignoring the ' +
                          'existence of a user-specific data structure. ' +
                          '(default: false)')

    encr_arg.add_argument('--plaintext', default=False,
                          action="store_true",
                          help='Do not try to decrypt the data. Instead, ' +
                          'assume that all API data transmissions are ' +
                          'plaintext and save them as individual files ' +
                          'named by timestamps in the  \"downloads/\" ' +
                          'folder. NOTE: this saves all transmissions in the ' +
                          ' \"downloads/\" folder. (default: false)')

    parser.add_argument('--password', default=False,
                        action="store_true",
                        help='Whether to access GPG keyring with a password ' +
                        '(default: false)')

    parser.add_argument('--debug', action='store_true',
                        help='Debug mode (default: false)')
    args      = parser.parse_args()
    sock_addr = args.sock_addr
    interface = args.interface
    gnupghome = args.gnupghome
    save_raw  = args.save_raw
    plaintext = args.plaintext

    # Switch debug level
    if (args.debug):
        logging.basicConfig(
            format='%(asctime)s %(levelname)-8s %(message)s',
            datefmt='%b %d %Y %H:%M:%S',
            level=logging.DEBUG)
        logging.debug('[Debug Mode]')
    else:
        logging.basicConfig(
            format='%(asctime)s %(levelname)-8s %(message)s',
            datefmt='%b %d %Y %H:%M:%S',
            level=logging.INFO)

    # GPG object
    if (not plaintext):
        gpg = gnupg.GPG(gnupghome = gnupghome)

        # Is there a password for GPG keyring?
        if (args.password):
            gpg_password = getpass.getpass()
        else:
            gpg_password = None

    # Open interface to API data
    sock = open_udp_sock(sock_addr, interface)

    logging.info("Waiting for data...")
    while True:
        udp_payload, addr = sock.recvfrom(MAX_READ)
        data, seq_num     = unpack(udp_payload)
        logging.info("-- API message %d" %(seq_num))
        logging.debug("Message source: %s:%s" %(addr[0], addr[1]))

        if (len(data) > 0):
            # In plaintext mode, every API transmission is assumed to be
            # plaintext and output as a file to the downloads folder with a
            # timestamp as name.
            if (plaintext):
                logging.info("Size: %7d bytes\tSaving as plaintext" %(len(data)))
                save_file(data)
                logging.debug("Message: %s" %data)
                continue

            # Try to decrypt the data when not in plaintext mode
            decrypted_data = gpg.decrypt(data, passphrase = gpg_password)

            if (decrypted_data.ok):
                # Is the message digitally signed?
                if (decrypted_data.fingerprint is not None):
                    signed_by = decrypted_data.fingerprint

                    # Was the signature verified?
                    if decrypted_data.trust_level is not None:
                        sign_str = "Signed by %s (verified w/ trust level: %s)" %(
                            signed_by, decrypted_data.trust_text
                        )
                    else:
                        sign_str = "Signed by %s (unverified)" %(signed_by)

                    unsign_str = ""
                else:
                    unsign_str = "Not signed"
                    sign_str = ""

                logging.info("Encrypted size: %7d bytes\t Decryption: OK    \t%s" %(
                    len(data), unsign_str))
                if (len(sign_str) > 0):
                    logging.info(sign_str)
                logging.info("Decrypted size: %7d bytes" %(len(str(decrypted_data))))

                # Parse the user-specific data structure. If ignoring the
                # existence of an application-specific data structure, save the
                # raw decrypted data directly to a file.
                if (save_raw):
                    save_file(str(decrypted_data))
                else:
                    parse_ok = parse_user_data(str(decrypted_data))

                    # Save raw data in case parsing fails
                    if (not parse_ok):
                        save_file(str(decrypted_data))
            else:
                logging.info(
                    "Size: %7d bytes\t Decryption: FAILED\t" %(len(data)) +
                    "Not encrypted for us (%s)" %(decrypted_data.status)
                )


if __name__ == '__main__':
    main()
